#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <string>
#include <vector>
#include <iomanip>
#include <chrono>

#include "types.h"
// #include "StatewithBDDEdges.h"
#include "TAwithBDDEdges.h"
// #include "FixpointwithBDDEdges.h"

#include "MightyPPL.h"

#include "Monitor.h"
#include "Parser.h"

using namespace mightypplcpp;
using namespace antlr4;


int main(int argc, const char ** argv) {

    const char* spec_file = NULL;
    const char* tck_file = NULL;

    if (argc >= 2) {

        spec_file = argv[1];

        if (argc >= 3) {

            tck_file = argv[2]; 

        }

    } else {

        std::cerr << "Usage: demo <in_spec_file> [out_tck_file]" << std::endl;
        std::cerr << "A standard fixpoint algorithm based on DBMs (PARDIBAAL) is used by default." << std::endl;
        std::cerr << "If out_tck_file specified a (flattened) TChecker model will be generated instead." << std::endl;
        return 1;

    }

    std::ifstream spec_in(spec_file, std::ios::in);
    if (!spec_in) {

        std::cerr << "Error: Could not open in_spec_file" << std::endl;
        return 1;

    }

    bdd_init(1000, 100);

    std::cout << "\n<<<<<< Pre-processing input formula... >>>>>>\n\n";

    std::cout << "\nInput formula (as read from input):\n";

    std::stringstream buf;
    buf << spec_in.rdbuf();
    std::cout << buf.str();

    std::string nnf_in = buf.str();

    ANTLRInputStream input(nnf_in);
    MitlLexer lexer(&input);
    CommonTokenStream tokens(&lexer);
    MitlParser parser(&tokens);

    MitlParser::MainContext* original_formula = parser.main();

    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
    monitaal::TA pos = build_ta_from_main(original_formula);
    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();

   
    std::cout << "Constructing TA (with BDD transitions) took = " << std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count() << "[ms]" << std::endl;
    // std::cout << pos << std::endl;


    if (tck_file == NULL) {

        std::chrono::steady_clock::time_point begin2 = std::chrono::steady_clock::now();
        std::cout << "<<<<<< Calculating fixpoints >>>>>>" << std::endl;
        auto recurrent = monitaal::Fixpoint::buchi_accept_fixpoint(pos);

        auto initial_state = monitaal::symbolic_state_t(pos.initial_location(), monitaal::Federation::zero(pos.number_of_clocks()));

        if (initial_state.is_included_in(monitaal::Fixpoint::reach(recurrent, pos))) {

            std::cout << "\n\n\033[32mSATISFIABLE\033[0m\n\n" << std::endl;

        } else {

            std::cout << "\n\n\033[31mNOT SATISFIABLE\033[0m\n\n" << std::endl;

        }

        std::chrono::steady_clock::time_point end2 = std::chrono::steady_clock::now();
        std::cout << "Fixpoint took = " << std::chrono::duration_cast<std::chrono::milliseconds>(end2 - begin2).count() << "[ms]" << std::endl;

    } else { 

        std::ofstream tck_out(tck_file, std::ios::trunc);
        if (!tck_out) {

            std::cerr << "Error: Could not open out_tck_file" << std::endl;
            return 1;

        }

        std::stringstream tck;

        tck << "# Model generated by MightyPPL" << std::endl;
        tck << "system:model_and_spec" << std::endl << std::endl << std::endl;

        tck << "event:a" << std::endl << std::endl << std::endl;

        for (auto i = 1; i < pos.number_of_clocks() - 1; ++i) {

            // In MoniTAal there is always x0 (meant to be 0 at all times)
            // And there is an extra "global" clock for monitoring in newer versions MoniTAal
            // So if number_of_clocks() returns 5, only 3 clocks are useful for tck

            tck << "clock:1:x_" << i << std::endl;

        }
        tck << std::endl << std::endl;

        tck << "# " << "TA" << std::endl;
        tck << "# " << "This is the (untimely-reachable part of the) product of component automata, TA_0, div, and M" << std::endl;
        tck << "process:" << "TA" << std::endl;

        for (const auto& [k, v] : pos.locations()) {

            tck << "location:" << "TA" << ":ell_" << k << "{" << (k == pos.initial_location() ?  "initial: : " : std::string{})
                << (v.is_accept() ? "labels: accept" : std::string{}) << "}" << std::endl;

        }
        tck << std::endl << std::endl;

        for (const auto& [k, v] : pos.locations()) {

            for (const auto& e : pos.edges_from(k)) {
                auto reset_clocks = e.reset();
                tck << "edge:TA:ell_" << e.from() << ":ell_" << e.to() << ":a{";

                std::string provided_str;
                for (const auto& g : e.guard()) {

                    if (!provided_str.empty()) {
                        provided_str += " && ";
                    }

                    if (g._i == 0) {

                        assert(g._j != 0);

                        if (g._bound.is_strict()) {
                            provided_str += "x_" + std::to_string(g._j) + " > " + std::to_string(-1 * g._bound.get_bound());
                        } else {
                            provided_str += "x_" + std::to_string(g._j) + " >= " + std::to_string(-1 * g._bound.get_bound());
                        }

                    } else if (g._j == 0) {

                        assert(g._i != 0);

                        if (g._bound.is_strict()) {
                            provided_str += "x_" + std::to_string(g._i) + " < " + std::to_string(g._bound.get_bound());
                        } else {
                            provided_str += "x_" + std::to_string(g._i) + " <= " + std::to_string(g._bound.get_bound());
                        }

                    } else {
                        assert(("Currently support only non-diagonal guards", false));
                    }

                }

                std::string do_str;
                for (const auto& r : e.reset()) {
            
                    if (!do_str.empty()) {
                        do_str += "; ";
                    }

                    do_str += "x_" + std::to_string(r) + " = 0";

                }

                tck << (provided_str.empty() ? std::string{} : "provided: ") << provided_str;
                tck << (provided_str.empty() || do_str.empty() ? std::string{} : " : ");
                tck << (do_str.empty() ? std::string{} : "do: ") << do_str;
                tck << "}" << std::endl;
            }

        }
        tck << std::endl << std::endl;

        tck_out << tck.str();

        std::cout << "\nPlease use the following command to check satisfiability:\n\n";
        std::cout << "tck-liveness -a couvscc -l accept out.tck" << std::endl;

        tck_out.close();

    }

    bdd_done();
    spec_in.close();

    return 0;

}
